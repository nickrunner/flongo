import { describe, it, expect, beforeEach, vi } from 'vitest';
import { InvalidationStrategy } from '../../cache/invalidationStrategy';
import { CacheStore } from '../../cache/cacheStore';
import { CacheKeyGenerator } from '../../cache/cacheKeyGenerator';
import { FlongoQuery } from '../../flongoQuery';
import { Entity } from '../../types';

// Mock CacheStore implementation
class MockCacheStore implements CacheStore<any> {
  private store = new Map<string, any>();
  
  async get(key: string): Promise<any> {
    return this.store.get(key);
  }
  
  async set(key: string, value: any): Promise<void> {
    this.store.set(key, value);
  }
  
  async delete(key: string): Promise<boolean> {
    return this.store.delete(key);
  }
  
  async clear(): Promise<void> {
    this.store.clear();
  }
  
  async has(key: string): Promise<boolean> {
    return this.store.has(key);
  }
  
  async size(): Promise<number> {
    return this.store.size;
  }
  
  async keys(): Promise<string[]> {
    return Array.from(this.store.keys());
  }
  
  async getStats(): Promise<any> {
    return { size: this.store.size };
  }
  
  async resetStats(): Promise<void> {}
}

describe('InvalidationStrategy', () => {
  let cacheStore: MockCacheStore;
  let invalidationStrategy: InvalidationStrategy;
  const collectionName = 'users';
  
  beforeEach(() => {
    cacheStore = new MockCacheStore();
    invalidationStrategy = new InvalidationStrategy(cacheStore, collectionName);
  });
  
  describe('invalidateOnCreate', () => {
    it('should invalidate count queries when document is created', async () => {
      // Setup: Add some cached queries
      const countKey = CacheKeyGenerator.generate({ collection: collectionName, operation: 'count' });
      const getAllKey = CacheKeyGenerator.generate({ collection: collectionName, operation: 'getAll' });
      const existsKey = CacheKeyGenerator.generate({ collection: collectionName, operation: 'exists', query: { name: 'test' } });
      
      await cacheStore.set(countKey, 10);
      await cacheStore.set(getAllKey, [{ _id: '1', name: 'user1' }]);
      await cacheStore.set(existsKey, false);
      
      // Act: Invalidate on create
      const newDoc: Entity & { name: string } = {
        _id: '2',
        name: 'user2',
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
      await invalidationStrategy.invalidateOnCreate(newDoc);
      
      // Assert: Check that relevant caches are cleared
      expect(await cacheStore.has(countKey)).toBe(false);
      expect(await cacheStore.has(getAllKey)).toBe(false);
      expect(await cacheStore.has(existsKey)).toBe(false);
    });
  });
  
  describe('invalidateOnUpdate', () => {
    it('should invalidate document-specific and collection queries on update', async () => {
      const docId = '123';
      const getKey = keyGenerator.generateKey('get', { id: docId });
      const getAllKey = keyGenerator.generateKey('getAll', {});
      const getSomeKey = keyGenerator.generateKey('getSome', { query: { active: true } });
      
      await cacheStore.set(getKey, { _id: docId, name: 'user' });
      await cacheStore.set(getAllKey, [{ _id: docId, name: 'user' }]);
      await cacheStore.set(getSomeKey, [{ _id: docId, name: 'user' }]);
      
      await invalidationStrategy.invalidateOnUpdate(docId, { name: 'updated' });
      
      // Document cache should be cleared
      expect(await cacheStore.has(getKey)).toBe(false);
      // Collection queries should be cleared
      expect(await cacheStore.has(getAllKey)).toBe(false);
      expect(await cacheStore.has(getSomeKey)).toBe(false);
    });
    
    it('should invalidate queries filtering on updated fields', async () => {
      const docId = '123';
      const queryKey = keyGenerator.generateKey('getAll', { query: { status: 'active' } });
      
      await cacheStore.set(queryKey, [{ _id: docId, status: 'active' }]);
      
      // Update the status field
      await invalidationStrategy.invalidateOnUpdate(docId, { status: 'inactive' });
      
      // Query filtering on status should be invalidated
      expect(await cacheStore.has(queryKey)).toBe(false);
    });
  });
  
  describe('invalidateOnDelete', () => {
    it('should invalidate document and all collection queries on delete', async () => {
      const docId = '123';
      const getKey = keyGenerator.generateKey('get', { id: docId });
      const countKey = keyGenerator.generateKey('count', {});
      const getAllKey = keyGenerator.generateKey('getAll', {});
      const existsKey = keyGenerator.generateKey('exists', { query: { _id: docId } });
      
      await cacheStore.set(getKey, { _id: docId });
      await cacheStore.set(countKey, 5);
      await cacheStore.set(getAllKey, [{ _id: docId }]);
      await cacheStore.set(existsKey, true);
      
      await invalidationStrategy.invalidateOnDelete(docId);
      
      // All related caches should be cleared
      expect(await cacheStore.has(getKey)).toBe(false);
      expect(await cacheStore.has(countKey)).toBe(false);
      expect(await cacheStore.has(getAllKey)).toBe(false);
      expect(await cacheStore.has(existsKey)).toBe(false);
    });
  });
  
  describe('invalidateOnBulkUpdate', () => {
    it('should invalidate entire collection when no query specified', async () => {
      const key1 = keyGenerator.generateKey('get', { id: '1' });
      const key2 = keyGenerator.generateKey('getAll', {});
      const key3 = keyGenerator.generateKey('count', {});
      
      await cacheStore.set(key1, { _id: '1' });
      await cacheStore.set(key2, [{ _id: '1' }]);
      await cacheStore.set(key3, 10);
      
      await invalidationStrategy.invalidateOnBulkUpdate(undefined, { status: 'updated' });
      
      // All collection caches should be cleared
      expect(await cacheStore.has(key1)).toBe(false);
      expect(await cacheStore.has(key2)).toBe(false);
      expect(await cacheStore.has(key3)).toBe(false);
    });
    
    it('should invalidate overlapping queries when query specified', async () => {
      const query = new FlongoQuery().where('status').eq('active');
      const key1 = keyGenerator.generateKey('getAll', { query: query.build() });
      const key2 = keyGenerator.generateKey('count', {});
      
      await cacheStore.set(key1, [{ _id: '1', status: 'active' }]);
      await cacheStore.set(key2, 5);
      
      await invalidationStrategy.invalidateOnBulkUpdate(query, { status: 'inactive' });
      
      // Both caches should be invalidated
      expect(await cacheStore.has(key1)).toBe(false);
      expect(await cacheStore.has(key2)).toBe(false);
    });
  });
  
  describe('invalidateOnBulkDelete', () => {
    it('should invalidate all specified documents and collection queries', async () => {
      const ids = ['1', '2', '3'];
      const key1 = keyGenerator.generateKey('get', { id: '1' });
      const key2 = keyGenerator.generateKey('get', { id: '2' });
      const key3 = keyGenerator.generateKey('getAll', {});
      const key4 = keyGenerator.generateKey('count', {});
      
      await cacheStore.set(key1, { _id: '1' });
      await cacheStore.set(key2, { _id: '2' });
      await cacheStore.set(key3, [{ _id: '1' }, { _id: '2' }, { _id: '3' }]);
      await cacheStore.set(key4, 10);
      
      await invalidationStrategy.invalidateOnBulkDelete(ids);
      
      // All related caches should be cleared
      expect(await cacheStore.has(key1)).toBe(false);
      expect(await cacheStore.has(key2)).toBe(false);
      expect(await cacheStore.has(key3)).toBe(false);
      expect(await cacheStore.has(key4)).toBe(false);
    });
  });
  
  describe('invalidateCollection', () => {
    it('should clear all caches for the collection', async () => {
      // Add caches for this collection
      const key1 = `${collectionName}:get:123`;
      const key2 = `${collectionName}:getAll:query`;
      const key3 = `${collectionName}:count:all`;
      
      // Add cache for different collection
      const otherKey = 'otherCollection:get:456';
      
      await cacheStore.set(key1, { _id: '123' });
      await cacheStore.set(key2, [{ _id: '123' }]);
      await cacheStore.set(key3, 5);
      await cacheStore.set(otherKey, { _id: '456' });
      
      await invalidationStrategy.invalidateCollection();
      
      // Only this collection's caches should be cleared
      expect(await cacheStore.has(key1)).toBe(false);
      expect(await cacheStore.has(key2)).toBe(false);
      expect(await cacheStore.has(key3)).toBe(false);
      // Other collection's cache should remain
      expect(await cacheStore.has(otherKey)).toBe(true);
    });
  });
  
  describe('invalidatePattern', () => {
    it('should invalidate caches matching the pattern', async () => {
      const key1 = `${collectionName}:count:all`;
      const key2 = `${collectionName}:count:filtered`;
      const key3 = `${collectionName}:get:123`;
      
      await cacheStore.set(key1, 10);
      await cacheStore.set(key2, 5);
      await cacheStore.set(key3, { _id: '123' });
      
      await invalidationStrategy.invalidatePattern('count:*');
      
      // Count caches should be cleared
      expect(await cacheStore.has(key1)).toBe(false);
      expect(await cacheStore.has(key2)).toBe(false);
      // Get cache should remain
      expect(await cacheStore.has(key3)).toBe(true);
    });
    
    it('should handle complex patterns', async () => {
      const key1 = `${collectionName}:get:id123`;
      const key2 = `${collectionName}:get:id456`;
      const key3 = `${collectionName}:getAll:query`;
      
      await cacheStore.set(key1, { _id: '123' });
      await cacheStore.set(key2, { _id: '456' });
      await cacheStore.set(key3, []);
      
      await invalidationStrategy.invalidatePattern('get:*123*');
      
      // Only key1 should be cleared
      expect(await cacheStore.has(key1)).toBe(false);
      expect(await cacheStore.has(key2)).toBe(true);
      expect(await cacheStore.has(key3)).toBe(true);
    });
  });
  
  describe('invalidateQuery', () => {
    it('should invalidate all operation types for a specific query', async () => {
      const query = new FlongoQuery().where('status').eq('active');
      const queryFilter = query.build();
      
      const getAllKey = keyGenerator.generateKey('getAll', { query: queryFilter });
      const getSomeKey = keyGenerator.generateKey('getSome', { query: queryFilter });
      const getFirstKey = keyGenerator.generateKey('getFirst', { query: queryFilter });
      const countKey = keyGenerator.generateKey('count', { query: queryFilter });
      const existsKey = keyGenerator.generateKey('exists', { query: queryFilter });
      
      // Set all cache entries
      await cacheStore.set(getAllKey, []);
      await cacheStore.set(getSomeKey, []);
      await cacheStore.set(getFirstKey, null);
      await cacheStore.set(countKey, 0);
      await cacheStore.set(existsKey, false);
      
      // Invalidate the query
      await invalidationStrategy.invalidateQuery(query);
      
      // All operation types for this query should be cleared
      expect(await cacheStore.has(getAllKey)).toBe(false);
      expect(await cacheStore.has(getSomeKey)).toBe(false);
      expect(await cacheStore.has(getFirstKey)).toBe(false);
      expect(await cacheStore.has(countKey)).toBe(false);
      expect(await cacheStore.has(existsKey)).toBe(false);
    });
  });
  
  describe('Custom invalidation hooks', () => {
    it('should execute registered invalidation hooks', async () => {
      const hookSpy = vi.fn();
      
      await invalidationStrategy.registerInvalidationHook(hookSpy);
      
      // Trigger invalidation
      await invalidationStrategy.invalidateOnCreate({ 
        _id: '123', 
        createdAt: Date.now(), 
        updatedAt: Date.now() 
      });
      
      // Hook should have been called
      // Note: The current implementation doesn't call hooks, 
      // so we'd need to update the implementation to include this
    });
  });
});