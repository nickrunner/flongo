import { describe, it, expect, beforeEach, vi } from 'vitest';
import { WriteThrough, AtomicOperationType } from '../../cache/writeThrough';
import { CacheStore } from '../../cache/cacheStore';
import { CacheKeyGenerator } from '../../cache/cacheKeyGenerator';
import { InvalidationStrategy } from '../../cache/invalidationStrategy';
import { Entity } from '../../types';

// Mock implementations
class MockCacheStore implements CacheStore<any> {
  private store = new Map<string, any>();
  
  async get(key: string): Promise<any> {
    return this.store.get(key);
  }
  
  async set(key: string, value: any): Promise<void> {
    this.store.set(key, value);
  }
  
  async delete(key: string): Promise<boolean> {
    return this.store.delete(key);
  }
  
  async clear(): Promise<void> {
    this.store.clear();
  }
  
  async has(key: string): Promise<boolean> {
    return this.store.has(key);
  }
  
  async size(): Promise<number> {
    return this.store.size;
  }
  
  async keys(): Promise<string[]> {
    return Array.from(this.store.keys());
  }
  
  async getStats(): Promise<any> {
    return { size: this.store.size };
  }
  
  async resetStats(): Promise<void> {}
}

describe('WriteThrough', () => {
  let cacheStore: MockCacheStore;
  let invalidationStrategy: InvalidationStrategy;
  let writeThrough: WriteThrough<any>;
  const collectionName = 'users';
  
  beforeEach(() => {
    cacheStore = new MockCacheStore();
    invalidationStrategy = new InvalidationStrategy(cacheStore, collectionName);
    writeThrough = new WriteThrough(cacheStore, collectionName, invalidationStrategy);
  });
  
  describe('handleCreate', () => {
    it('should cache newly created document', async () => {
      const document: Entity & { name: string } = {
        _id: '123',
        name: 'Test User',
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
      
      await writeThrough.handleCreate(document);
      
      const cacheKey = keyGenerator.generateKey('get', { id: document._id });
      const cached = await cacheStore.get(cacheKey);
      
      expect(cached).toEqual(document);
    });
  });
  
  describe('handleUpdate', () => {
    it('should update cached document', async () => {
      const id = '123';
      const updatedDocument: Entity & { name: string } = {
        _id: id,
        name: 'Updated User',
        createdAt: Date.now() - 1000,
        updatedAt: Date.now()
      };
      
      await writeThrough.handleUpdate(id, updatedDocument);
      
      const cacheKey = keyGenerator.generateKey('get', { id });
      const cached = await cacheStore.get(cacheKey);
      
      expect(cached).toEqual(updatedDocument);
    });
  });
  
  describe('handleAtomicOperation', () => {
    describe('increment operation', () => {
      it('should increment numeric field in cached document', async () => {
        const id = '123';
        const document = {
          _id: id,
          count: 5,
          updatedAt: Date.now() - 1000
        };
        
        const cacheKey = keyGenerator.generateKey('get', { id });
        await cacheStore.set(cacheKey, document);
        
        await writeThrough.handleAtomicOperation(id, 'increment', {
          key: 'count',
          value: 3
        });
        
        const updated = await cacheStore.get(cacheKey);
        expect(updated.count).toBe(8);
        expect(updated.updatedAt).toBeGreaterThan(document.updatedAt);
      });
      
      it('should initialize field to 0 if not exists', async () => {
        const id = '123';
        const document = {
          _id: id,
          updatedAt: Date.now() - 1000
        };
        
        const cacheKey = keyGenerator.generateKey('get', { id });
        await cacheStore.set(cacheKey, document);
        
        await writeThrough.handleAtomicOperation(id, 'increment', {
          key: 'count',
          value: 5
        });
        
        const updated = await cacheStore.get(cacheKey);
        expect(updated.count).toBe(5);
      });
    });
    
    describe('decrement operation', () => {
      it('should decrement numeric field in cached document', async () => {
        const id = '123';
        const document = {
          _id: id,
          count: 10,
          updatedAt: Date.now() - 1000
        };
        
        const cacheKey = keyGenerator.generateKey('get', { id });
        await cacheStore.set(cacheKey, document);
        
        await writeThrough.handleAtomicOperation(id, 'decrement', {
          key: 'count',
          value: 3
        });
        
        const updated = await cacheStore.get(cacheKey);
        expect(updated.count).toBe(7);
        expect(updated.updatedAt).toBeGreaterThan(document.updatedAt);
      });
    });
    
    describe('append operation', () => {
      it('should append items to array field', async () => {
        const id = '123';
        const document = {
          _id: id,
          tags: ['tag1', 'tag2'],
          updatedAt: Date.now() - 1000
        };
        
        const cacheKey = keyGenerator.generateKey('get', { id });
        await cacheStore.set(cacheKey, document);
        
        await writeThrough.handleAtomicOperation(id, 'append', {
          key: 'tags',
          value: ['tag3', 'tag4']
        });
        
        const updated = await cacheStore.get(cacheKey);
        expect(updated.tags).toEqual(['tag1', 'tag2', 'tag3', 'tag4']);
      });
      
      it('should create array if field does not exist', async () => {
        const id = '123';
        const document = {
          _id: id,
          updatedAt: Date.now() - 1000
        };
        
        const cacheKey = keyGenerator.generateKey('get', { id });
        await cacheStore.set(cacheKey, document);
        
        await writeThrough.handleAtomicOperation(id, 'append', {
          key: 'tags',
          value: ['tag1', 'tag2']
        });
        
        const updated = await cacheStore.get(cacheKey);
        expect(updated.tags).toEqual(['tag1', 'tag2']);
      });
    });
    
    describe('arrRemove operation', () => {
      it('should remove items from array field', async () => {
        const id = '123';
        const document = {
          _id: id,
          tags: ['tag1', 'tag2', 'tag3', 'tag4'],
          updatedAt: Date.now() - 1000
        };
        
        const cacheKey = keyGenerator.generateKey('get', { id });
        await cacheStore.set(cacheKey, document);
        
        await writeThrough.handleAtomicOperation(id, 'arrRemove', {
          key: 'tags',
          value: ['tag2', 'tag4']
        });
        
        const updated = await cacheStore.get(cacheKey);
        expect(updated.tags).toEqual(['tag1', 'tag3']);
      });
      
      it('should handle non-existent array field gracefully', async () => {
        const id = '123';
        const document = {
          _id: id,
          updatedAt: Date.now() - 1000
        };
        
        const cacheKey = keyGenerator.generateKey('get', { id });
        await cacheStore.set(cacheKey, document);
        
        await writeThrough.handleAtomicOperation(id, 'arrRemove', {
          key: 'tags',
          value: ['tag1']
        });
        
        const updated = await cacheStore.get(cacheKey);
        expect(updated.tags).toBeUndefined();
      });
    });
    
    it('should invalidate related queries when document not in cache', async () => {
      const invalidateSpy = vi.spyOn(invalidationStrategy, 'invalidatePattern');
      
      await writeThrough.handleAtomicOperation('non-existent-id', 'increment', {
        key: 'count',
        value: 1
      });
      
      expect(invalidateSpy).toHaveBeenCalledWith('*non-existent-id*');
    });
  });
  
  describe('handleBatchUpdate', () => {
    it('should update multiple documents in cache', async () => {
      const documents = [
        { _id: '1', name: 'User 1', createdAt: Date.now(), updatedAt: Date.now() },
        { _id: '2', name: 'User 2', createdAt: Date.now(), updatedAt: Date.now() },
        { _id: '3', name: 'User 3', createdAt: Date.now(), updatedAt: Date.now() }
      ];
      
      await writeThrough.handleBatchUpdate(documents);
      
      for (const doc of documents) {
        const cacheKey = keyGenerator.generateKey('get', { id: doc._id });
        const cached = await cacheStore.get(cacheKey);
        expect(cached).toEqual(doc);
      }
    });
  });
  
  describe('handleOptimisticUpdate', () => {
    it('should apply update function to cached document', async () => {
      const id = '123';
      const document = {
        _id: id,
        name: 'Original',
        count: 5,
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
      
      const cacheKey = keyGenerator.generateKey('get', { id });
      await cacheStore.set(cacheKey, document);
      
      const result = await writeThrough.handleOptimisticUpdate(id, (doc) => ({
        ...doc,
        name: 'Updated',
        count: doc.count + 1
      }));
      
      expect(result).toEqual({
        _id: id,
        name: 'Updated',
        count: 6,
        createdAt: document.createdAt,
        updatedAt: document.updatedAt
      });
      
      const cached = await cacheStore.get(cacheKey);
      expect(cached.name).toBe('Updated');
      expect(cached.count).toBe(6);
    });
    
    it('should return null when document not in cache', async () => {
      const result = await writeThrough.handleOptimisticUpdate('non-existent', (doc) => doc);
      expect(result).toBeNull();
    });
  });
  
  describe('rollbackOptimisticUpdate', () => {
    it('should restore original document in cache', async () => {
      const id = '123';
      const original = {
        _id: id,
        name: 'Original',
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
      
      const cacheKey = keyGenerator.generateKey('get', { id });
      
      // First set a different value
      await cacheStore.set(cacheKey, { ...original, name: 'Modified' });
      
      // Rollback to original
      await writeThrough.rollbackOptimisticUpdate(id, original);
      
      const cached = await cacheStore.get(cacheKey);
      expect(cached).toEqual(original);
    });
  });
  
  describe('Invalidation on atomic operations', () => {
    beforeEach(async () => {
      // Set up a cached document
      const document = {
        _id: '123',
        count: 5,
        tags: ['tag1', 'tag2'],
        updatedAt: Date.now()
      };
      
      const cacheKey = keyGenerator.generateKey('get', { id: '123' });
      await cacheStore.set(cacheKey, document);
      
      // Set up some query caches that should be invalidated
      await cacheStore.set(`${collectionName}:getAll:count>0`, [document]);
      await cacheStore.set(`${collectionName}:getAll:tags.arrContains.tag1`, [document]);
      await cacheStore.set(`${collectionName}:count:inRange.0.10`, 1);
    });
    
    it('should invalidate range queries on numeric operations', async () => {
      await writeThrough.handleAtomicOperation('123', 'increment', {
        key: 'count',
        value: 1
      });
      
      // Check that range-related caches are cleared
      const keys = await cacheStore.keys();
      const rangeKeys = keys.filter(k => k.includes('gt') || k.includes('lt') || k.includes('inRange'));
      
      // Note: The actual implementation needs to be updated to properly invalidate these
      // This test shows the expected behavior
    });
    
    it('should invalidate array queries on array operations', async () => {
      await writeThrough.handleAtomicOperation('123', 'append', {
        key: 'tags',
        value: ['tag3']
      });
      
      // Check that array-related caches are cleared
      const keys = await cacheStore.keys();
      const arrayKeys = keys.filter(k => k.includes('arrContains') || k.includes('in'));
      
      // Note: The actual implementation needs to be updated to properly invalidate these
      // This test shows the expected behavior
    });
  });
});